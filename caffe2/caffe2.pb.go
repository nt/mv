// Code generated by protoc-gen-go.
// source: caffe2.proto
// DO NOT EDIT!

/*
Package caffe2 is a generated protocol buffer package.

It is generated from these files:
	caffe2.proto

It has these top-level messages:
	TensorProto
	TensorProtos
	Argument
	DeviceOption
	OperatorDef
	NetDef
	ExecutionStep
	PlanDef
	SimpleClientDef
*/
package caffe2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DeviceType int32

const (
	DeviceType_CPU   DeviceType = 0
	DeviceType_CUDA  DeviceType = 1
	DeviceType_CUDNN DeviceType = 2
)

var DeviceType_name = map[int32]string{
	0: "CPU",
	1: "CUDA",
	2: "CUDNN",
}
var DeviceType_value = map[string]int32{
	"CPU":   0,
	"CUDA":  1,
	"CUDNN": 2,
}

func (x DeviceType) Enum() *DeviceType {
	p := new(DeviceType)
	*p = x
	return p
}
func (x DeviceType) String() string {
	return proto.EnumName(DeviceType_name, int32(x))
}
func (x *DeviceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DeviceType_value, data, "DeviceType")
	if err != nil {
		return err
	}
	*x = DeviceType(value)
	return nil
}

type TensorProto_DataType int32

const (
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_INT32  TensorProto_DataType = 2
	TensorProto_BYTE   TensorProto_DataType = 3
	TensorProto_STRING TensorProto_DataType = 4
)

var TensorProto_DataType_name = map[int32]string{
	1: "FLOAT",
	2: "INT32",
	3: "BYTE",
	4: "STRING",
}
var TensorProto_DataType_value = map[string]int32{
	"FLOAT":  1,
	"INT32":  2,
	"BYTE":   3,
	"STRING": 4,
}

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}
func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}
func (x *TensorProto_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_DataType_value, data, "TensorProto_DataType")
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(value)
	return nil
}

type TensorProto struct {
	// The dimensions in the tensor.
	Dims             []int32               `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	DataType         *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,enum=caffe2.TensorProto_DataType,def=1" json:"data_type,omitempty"`
	FloatData        []float32             `protobuf:"fixed32,3,rep,packed,name=float_data" json:"float_data,omitempty"`
	Int32Data        []int32               `protobuf:"varint,4,rep,packed,name=int32_data" json:"int32_data,omitempty"`
	ByteData         []byte                `protobuf:"bytes,5,opt,name=byte_data" json:"byte_data,omitempty"`
	StringData       [][]byte              `protobuf:"bytes,6,rep,name=string_data" json:"string_data,omitempty"`
	Name             *string               `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TensorProto) Reset()         { *m = TensorProto{} }
func (m *TensorProto) String() string { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()    {}

const Default_TensorProto_DataType TensorProto_DataType = TensorProto_FLOAT

func (m *TensorProto) GetDims() []int32 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return Default_TensorProto_DataType
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetByteData() []byte {
	if m != nil {
		return m.ByteData
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type TensorProtos struct {
	Protos           []*TensorProto `protobuf:"bytes,1,rep,name=protos" json:"protos,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *TensorProtos) Reset()         { *m = TensorProtos{} }
func (m *TensorProtos) String() string { return proto.CompactTextString(m) }
func (*TensorProtos) ProtoMessage()    {}

func (m *TensorProtos) GetProtos() []*TensorProto {
	if m != nil {
		return m.Protos
	}
	return nil
}

type Argument struct {
	Name             *string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	F                *float32  `protobuf:"fixed32,2,opt,name=f" json:"f,omitempty"`
	I                *int32    `protobuf:"varint,3,opt,name=i" json:"i,omitempty"`
	S                *string   `protobuf:"bytes,4,opt,name=s" json:"s,omitempty"`
	Floats           []float32 `protobuf:"fixed32,5,rep,name=floats" json:"floats,omitempty"`
	Ints             []int32   `protobuf:"varint,6,rep,name=ints" json:"ints,omitempty"`
	Strings          []string  `protobuf:"bytes,7,rep,name=strings" json:"strings,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *Argument) Reset()         { *m = Argument{} }
func (m *Argument) String() string { return proto.CompactTextString(m) }
func (*Argument) ProtoMessage()    {}

func (m *Argument) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Argument) GetF() float32 {
	if m != nil && m.F != nil {
		return *m.F
	}
	return 0
}

func (m *Argument) GetI() int32 {
	if m != nil && m.I != nil {
		return *m.I
	}
	return 0
}

func (m *Argument) GetS() string {
	if m != nil && m.S != nil {
		return *m.S
	}
	return ""
}

func (m *Argument) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *Argument) GetInts() []int32 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *Argument) GetStrings() []string {
	if m != nil {
		return m.Strings
	}
	return nil
}

type DeviceOption struct {
	// Options that need to be carried out before running the execution.
	DeviceType *DeviceType `protobuf:"varint,1,opt,name=device_type,enum=caffe2.DeviceType,def=0" json:"device_type,omitempty"`
	// the cuda gpu id. If the device is not CUDA, this field will simply be
	// ignored.
	CudaGpuId *int32 `protobuf:"varint,2,opt,name=cuda_gpu_id" json:"cuda_gpu_id,omitempty"`
	// The random seed to start the device random number generator with.
	RandomSeed       *uint32 `protobuf:"varint,3,opt,name=random_seed" json:"random_seed,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DeviceOption) Reset()         { *m = DeviceOption{} }
func (m *DeviceOption) String() string { return proto.CompactTextString(m) }
func (*DeviceOption) ProtoMessage()    {}

const Default_DeviceOption_DeviceType DeviceType = DeviceType_CPU

func (m *DeviceOption) GetDeviceType() DeviceType {
	if m != nil && m.DeviceType != nil {
		return *m.DeviceType
	}
	return Default_DeviceOption_DeviceType
}

func (m *DeviceOption) GetCudaGpuId() int32 {
	if m != nil && m.CudaGpuId != nil {
		return *m.CudaGpuId
	}
	return 0
}

func (m *DeviceOption) GetRandomSeed() uint32 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return 0
}

type OperatorDef struct {
	Input            []string                  `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output           []string                  `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"`
	Name             *string                   `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Type             *string                   `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	Arg              []*Argument               `protobuf:"bytes,5,rep,name=arg" json:"arg,omitempty"`
	DeviceOption     *DeviceOption             `protobuf:"bytes,6,opt,name=device_option" json:"device_option,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *OperatorDef) Reset()         { *m = OperatorDef{} }
func (m *OperatorDef) String() string { return proto.CompactTextString(m) }
func (*OperatorDef) ProtoMessage()    {}

var extRange_OperatorDef = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*OperatorDef) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_OperatorDef
}
func (m *OperatorDef) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *OperatorDef) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *OperatorDef) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *OperatorDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *OperatorDef) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *OperatorDef) GetArg() []*Argument {
	if m != nil {
		return m.Arg
	}
	return nil
}

func (m *OperatorDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

type NetDef struct {
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Operators that the network contains.
	// Note(Yangqing): I did not name it "operator" because that is a reserved
	// word in C++.
	Op []*OperatorDef `protobuf:"bytes,2,rep,name=op" json:"op,omitempty"`
	// net_type and net_args are implementation-specific parameters that we want
	// to pass to specialized implementations. If you do not care about this, you
	// don't need to set them.
	NetType *string `protobuf:"bytes,3,opt,name=net_type" json:"net_type,omitempty"`
	// the number of workers, if the operators in the network is to be carried out
	// in parallel.
	NumWorkers *int32 `protobuf:"varint,4,opt,name=num_workers" json:"num_workers,omitempty"`
	// The device option for the network. If a network has a specific device
	// option and one of its operators does not have it set, we will copy over the
	// device option to the operator. This allows us to basically avoid putting
	// device options at every operator.
	DeviceOption     *DeviceOption `protobuf:"bytes,5,opt,name=device_option" json:"device_option,omitempty"`
	XXX_unrecognized []byte        `json:"-"`
}

func (m *NetDef) Reset()         { *m = NetDef{} }
func (m *NetDef) String() string { return proto.CompactTextString(m) }
func (*NetDef) ProtoMessage()    {}

func (m *NetDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NetDef) GetOp() []*OperatorDef {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *NetDef) GetNetType() string {
	if m != nil && m.NetType != nil {
		return *m.NetType
	}
	return ""
}

func (m *NetDef) GetNumWorkers() int32 {
	if m != nil && m.NumWorkers != nil {
		return *m.NumWorkers
	}
	return 0
}

func (m *NetDef) GetDeviceOption() *DeviceOption {
	if m != nil {
		return m.DeviceOption
	}
	return nil
}

// ExecutionStep is actually a sort-of-hacky way we simulate iteration right
// now.
type ExecutionStep struct {
	// ExecutionStep should either contain a set of substeps, or a set of
	// network names to run in this execution step. They should NOT both be set
	// at the same time.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// An execution step could be recursive, in which it involves a set of
	// substeps.
	Substep []*ExecutionStep `protobuf:"bytes,2,rep,name=substep" json:"substep,omitempty"`
	// Alternatively, an execution step could involve one or more networks.
	// Note that you cannot have both substeps and networks. Choose one.
	// Note that an executionstep refers networks by their name. The actual
	// network definition of the same name should be included in the network field
	// of the plan. The reason is that a network object might hold internal states
	// (think of a data layer), so we want to have the same network object that
	// multiple steps could ask to run.
	Network []string `protobuf:"bytes,3,rep,name=network" json:"network,omitempty"`
	// Number of iterations to run this step. The substeps or the networks
	// specified will be run sequentially, and one sequential run is considered
	// one iteration. If this is not set, the number of iterations is assumed to
	// be 1.
	NumIter          *int32 `protobuf:"varint,4,opt,name=num_iter" json:"num_iter,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ExecutionStep) Reset()         { *m = ExecutionStep{} }
func (m *ExecutionStep) String() string { return proto.CompactTextString(m) }
func (*ExecutionStep) ProtoMessage()    {}

func (m *ExecutionStep) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ExecutionStep) GetSubstep() []*ExecutionStep {
	if m != nil {
		return m.Substep
	}
	return nil
}

func (m *ExecutionStep) GetNetwork() []string {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *ExecutionStep) GetNumIter() int32 {
	if m != nil && m.NumIter != nil {
		return *m.NumIter
	}
	return 0
}

type PlanDef struct {
	// All the networks that are used in this execution. Note that networks should
	// be orderd in the way they are executed, i.e. for a layer in a network, all
	// its input blobs should already have been initialized by the layers or
	// networks defined before it.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// The networks that are going to be used in this plan.
	Network          []*NetDef        `protobuf:"bytes,2,rep,name=network" json:"network,omitempty"`
	ExecutionStep    []*ExecutionStep `protobuf:"bytes,3,rep,name=execution_step" json:"execution_step,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *PlanDef) Reset()         { *m = PlanDef{} }
func (m *PlanDef) String() string { return proto.CompactTextString(m) }
func (*PlanDef) ProtoMessage()    {}

func (m *PlanDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *PlanDef) GetNetwork() []*NetDef {
	if m != nil {
		return m.Network
	}
	return nil
}

func (m *PlanDef) GetExecutionStep() []*ExecutionStep {
	if m != nil {
		return m.ExecutionStep
	}
	return nil
}

// ClientDef is a model we use to ship a pre-trained model. This contains two
// parts basically: one set of parameters, and one network.
type SimpleClientDef struct {
	Name             *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	InitNet          *NetDef `protobuf:"bytes,2,opt,name=init_net" json:"init_net,omitempty"`
	MainNet          *NetDef `protobuf:"bytes,3,opt,name=main_net" json:"main_net,omitempty"`
	Input            *string `protobuf:"bytes,4,opt,name=input" json:"input,omitempty"`
	Output           *string `protobuf:"bytes,5,opt,name=output" json:"output,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SimpleClientDef) Reset()         { *m = SimpleClientDef{} }
func (m *SimpleClientDef) String() string { return proto.CompactTextString(m) }
func (*SimpleClientDef) ProtoMessage()    {}

func (m *SimpleClientDef) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *SimpleClientDef) GetInitNet() *NetDef {
	if m != nil {
		return m.InitNet
	}
	return nil
}

func (m *SimpleClientDef) GetMainNet() *NetDef {
	if m != nil {
		return m.MainNet
	}
	return nil
}

func (m *SimpleClientDef) GetInput() string {
	if m != nil && m.Input != nil {
		return *m.Input
	}
	return ""
}

func (m *SimpleClientDef) GetOutput() string {
	if m != nil && m.Output != nil {
		return *m.Output
	}
	return ""
}

func init() {
	proto.RegisterEnum("caffe2.DeviceType", DeviceType_name, DeviceType_value)
	proto.RegisterEnum("caffe2.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
}
